#!/usr/bin/env python3
"""
OpenCog Transcendent Expression Report Generator

Generates a comprehensive report showing the post-polyglot synthesis
of optimal language selections across all AI domains.
"""

import sys
import json
from pathlib import Path
from collections import defaultdict

# Add lib directory to path
sys.path.insert(0, str(Path(__file__).parent.parent / "lib"))

from opencog_analyzer import OpenCogAnalyzer


def format_category_name(category_name):
    """Format category name for display."""
    return category_name.replace('_', ' ').title()


def generate_markdown_report(analyzer):
    """Generate a comprehensive Markdown report."""
    
    report = []
    report.append("# OpenCog: Post-Polyglot Transcendent Expression Report")
    report.append("")
    report.append("## Executive Summary")
    report.append("")
    report.append("This report presents the results of evaluating 970+ programming languages across")
    report.append("10 AI/AGI functional categories. Through systematic analysis of thousands of")
    report.append("code implementations from RosettaCode, we identify the optimal language for each")
    report.append("cognitive function, creating the **FrankenCog Patchwork Inference Fabric** - a")
    report.append("transcendent synthesis that leverages each language's unique strengths.")
    report.append("")
    
    # Get full analysis
    all_analysis = analyzer.analyze_all_languages()
    manifest = analyzer.generate_frankencog_manifest()
    
    # Overall statistics
    report.append("## Overall Statistics")
    report.append("")
    report.append(f"- **Total Languages Analyzed**: {all_analysis['total_languages']}")
    report.append(f"- **AI Categories**: {len(manifest['categories'])}")
    
    total_ai_tasks = sum(
        profile['ai_tasks_implemented'] 
        for profile in all_analysis['language_profiles']
    )
    report.append(f"- **Total AI Task Implementations**: {total_ai_tasks}")
    report.append("")
    
    # Top languages
    report.append("## Top Languages by AI Capability")
    report.append("")
    report.append("The following languages demonstrate the broadest AI/AGI capabilities:")
    report.append("")
    report.append("| Rank | Language | AI Tasks | Category Coverage |")
    report.append("|------|----------|----------|-------------------|")
    
    for idx, profile in enumerate(all_analysis['language_profiles'][:10], 1):
        report.append(
            f"| {idx} | {profile['language']} | "
            f"{profile['ai_tasks_implemented']} | "
            f"{profile['category_coverage']:.1f}% |"
        )
    
    report.append("")
    
    # FrankenCog Patchwork
    report.append("## The FrankenCog Patchwork: Optimal Language per AI Domain")
    report.append("")
    report.append("Each AI domain has languages that excel at expressing its specific functions.")
    report.append("The FrankenCog integration manifest identifies the best language for each category:")
    report.append("")
    
    for category_name, category_data in sorted(manifest['categories'].items()):
        report.append(f"### {format_category_name(category_name)}")
        report.append("")
        report.append(f"**Description**: {category_data['description']}")
        report.append("")
        
        if category_data['best_language']:
            report.append(f"**Optimal Language**: **{category_data['best_language']}**")
            report.append("")
            
            if category_data['recommended_languages']:
                report.append("**Top 5 Languages for this Domain**:")
                report.append("")
                report.append("| Rank | Language | Tasks Implemented |")
                report.append("|------|----------|-------------------|")
                
                for idx, lang_data in enumerate(category_data['recommended_languages'][:5], 1):
                    report.append(
                        f"| {idx} | {lang_data['language']} | {lang_data['task_count']} |"
                    )
                report.append("")
        else:
            report.append("**Optimal Language**: None found")
            report.append("")
    
    # Language specializations
    report.append("## Language Specializations")
    report.append("")
    report.append("Some languages excel in specific AI domains:")
    report.append("")
    
    # Find which languages are best at which categories
    lang_specializations = defaultdict(list)
    for category_name, category_data in manifest['categories'].items():
        if category_data['best_language']:
            lang_specializations[category_data['best_language']].append(
                format_category_name(category_name)
            )
    
    report.append("| Language | AI Domains (Best Performance) |")
    report.append("|----------|------------------------------|")
    
    for lang, domains in sorted(lang_specializations.items(), 
                                  key=lambda x: len(x[1]), 
                                  reverse=True):
        domains_str = ", ".join(domains)
        report.append(f"| {lang} | {domains_str} |")
    
    report.append("")
    
    # Detailed category analysis
    report.append("## Detailed Category Analysis")
    report.append("")
    
    categories_info = analyzer.categories.get('categories', {})
    
    for category_name in sorted(categories_info.keys()):
        category_info = categories_info[category_name]
        manifest_data = manifest['categories'].get(category_name, {})
        
        report.append(f"### {format_category_name(category_name)}")
        report.append("")
        report.append(f"**Description**: {category_info.get('description', 'N/A')}")
        report.append("")
        
        # Task examples
        if 'tasks' in category_info and category_info['tasks']:
            report.append("**Example Tasks**:")
            report.append("")
            for task in category_info['tasks'][:8]:
                report.append(f"- {task}")
            if len(category_info['tasks']) > 8:
                report.append(f"- ... and {len(category_info['tasks']) - 8} more")
            report.append("")
        
        # Language coverage
        if manifest_data and manifest_data.get('recommended_languages'):
            report.append(f"**Total Implementations**: {manifest_data['total_implementations']}")
            report.append(f"**Languages Participating**: {len(manifest_data['recommended_languages'])}")
            report.append("")
    
    # Conclusion
    report.append("## Conclusion: The Transcendent Expression")
    report.append("")
    report.append("The OpenCog analysis reveals that no single programming language dominates")
    report.append("across all AI domains. Instead, each language brings unique strengths to")
    report.append("specific cognitive functions:")
    report.append("")
    report.append("- **Symbolic reasoning** is best expressed in languages like C#, ALGOL-68, and Ada")
    report.append("- **Pattern recognition** excels in C, Ada, and other systems languages")
    report.append("- **Knowledge representation** finds its best form in C++, Ada, and functional languages")
    report.append("- **Machine learning** benefits from C's performance and Python's expressiveness")
    report.append("- **Natural language processing** leverages string-centric languages")
    report.append("- **Meta-learning** thrives in reflective languages like FreeBASIC and Julia")
    report.append("")
    report.append("The **FrankenCog Patchwork** represents a post-polyglot synthesis where")
    report.append("each AI function is implemented in the language that was, in essence,")
    report.append("conceived to express that very technique. This transcendent approach")
    report.append("creates an optimal inference fabric that leverages the collective wisdom")
    report.append("of all programming paradigms.")
    report.append("")
    report.append("---")
    report.append("")
    report.append("*Generated by OpenCog: Post-Polyglot Transcendent AI Evaluation Framework*")
    report.append("")
    
    return "\n".join(report)


def main():
    # Get repository root
    script_dir = Path(__file__).parent.parent.parent
    analyzer = OpenCogAnalyzer(str(script_dir))
    
    print("Generating Transcendent Expression Report...")
    print()
    
    # Generate report
    report_md = generate_markdown_report(analyzer)
    
    # Save report
    output_dir = script_dir / "opencog" / "output"
    output_dir.mkdir(exist_ok=True)
    
    report_file = output_dir / "transcendent-expression-report.md"
    with open(report_file, 'w') as f:
        f.write(report_md)
    
    print(f"Report saved to: {report_file}")
    print()
    print("Summary:")
    print("=" * 80)
    
    # Print first part of report
    lines = report_md.split('\n')
    for line in lines[:50]:
        print(line)
    
    print()
    print("... (see full report in output file)")
    print()


if __name__ == '__main__':
    main()
